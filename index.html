<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Store Half Byte-Reverse Indexed</title>
  <meta name="author" content="OzLabs">

  <link href="https://sthbrx.github.io/rss.xml" type="application/rss+xml" rel="alternate"
        title="Store Half Byte-Reverse Indexed RSS Feed" />



  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">


    <link href="https://sthbrx.github.io/favicon.png" rel="icon">

  <link href="https://sthbrx.github.io/theme/css/main.css" media="screen, projection"
        rel="stylesheet" type="text/css">

  <link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic"
        rel="stylesheet" type="text/css">
  <link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic"
        rel="stylesheet" type="text/css">
</head>

<body>
  <header role="banner"><hgroup>
  <h1><a href="https://sthbrx.github.io/">Store Half Byte-Reverse Indexed</a></h1>
    <h2>A Power Technical Blog</h2>
</hgroup></header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="https://sthbrx.github.io/rss.xml" rel="subscribe-rss">RSS</a></li>
</ul>


<ul class="main-navigation">
      <li >
        <a href="https://sthbrx.github.io/category/development.html">Development</a>
      </li>
      <li >
        <a href="https://sthbrx.github.io/category/docker.html">Docker</a>
      </li>
      <li >
        <a href="https://sthbrx.github.io/category/education.html">Education</a>
      </li>
      <li >
        <a href="https://sthbrx.github.io/category/education-qemu-virtualisation.html">Education, QEMU, Virtualisation</a>
      </li>
      <li >
        <a href="https://sthbrx.github.io/category/openpower.html">OpenPOWER</a>
      </li>
      <li >
        <a href="https://sthbrx.github.io/category/petitboot.html">Petitboot</a>
      </li>
      <li >
        <a href="https://sthbrx.github.io/category/snowpatch.html">snowpatch</a>
      </li>
</ul></nav>
  <div id="main">
    <div id="content">
<div class="blog-index">
  		<article>
<header>
      <h1 class="entry-title">
        <a href="https://sthbrx.github.io/blog/2017/01/30/extracting-early-boot-messages-in-qemu/">Extracting Early Boot Messages in QEMU</a>
      </h1>
    <p class="meta">
<time datetime="2017-01-30T16:47:00+11:00" pubdate>Mon 30 January 2017</time>    </p>
</header>

<div class="byline_index">
  <span class="byline author vcard">
    Posted by <span class="fn">
        <a href="https://sthbrx.github.io/author/suraj-jitindar-singh.html">Suraj Jitindar Singh</a>
    </span>
  </span>
<time datetime="2017-01-30T16:47:00+11:00" pubdate>Mon 30 January 2017</time></div>

  <div class="entry-content"><p>Be me, you're a kernel hacker, you make some changes to your kernel, you boot
test it in QEMU, and it fails to boot. Even worse is the fact that it just hangs
without any failure message, no stack trace, no nothing. "Now what?" you think
to yourself.</p>
<p>You probably do the first thing you learnt in debugging101 and add abundant
print statements all over the place to try and make some sense of what's
happening and where it is that you're actually crashing. So you do this, you
recompile your kernel, boot it in QEMU and lo and behold, nothing... What
happened? You added all these shiny new print statements, where did the output
go? The kernel still failed to boot (obviously), but where you were hoping to
get some clue to go on you were again left with an empty screen. "Maybe I
didn't print early enough" or "maybe I got the code paths wrong" you think,
"maybe I just need more prints" even. So lets delve a bit deeper, why didn't
you see those prints, where did they go, and how can you get at them?</p>
<h1>__log_buf</h1>
<p>So what happens when you call printk()? Well what normally happens is,
depending on the log level you set, the output is sent to the console or logged
so you can see it in dmesg. But what happens if we haven't registered a console
yet? Well then we can't print the message can we, so its logged in a buffer,
kernel log buffer to be exact helpfully named __log_buf.</p>
<h1>Console Registration</h1>
<p>So how come I eventually see print statements on my screen? Well at some point
during the boot process a console is registered with the printk system, and any
buffered output can now be displayed. On ppc it happens that this occurs in
register_early_udbg_console() called in setup_arch() from start_kernel(),
which is the generic kernel entry point. From this point forward when you print
something it will be displayed on the console, but what if you crash before
this? What are you supposed to do then?</p>
<h1>Extracting Early Boot Messages in QEMU</h1>
<p>And now the moment you've all been waiting for, how do I extract those early
boot messages in QEMU if my kernel crashes before the console is registered?
Well it's quite simple really, QEMU is nice enough to allow us to dump guest
memory, and we know the log buffer is in there some where, so we just need to
dump the correct part of memory which corresponds to the log buffer.</p>
<h4>Locating __log_buf</h4>
<p>Before we can dump the log buffer we need to know where it is. Luckily for us
this is fairly simple, we just need to dump all the kernel symbols and look for
the right one.</p>
<div class="highlight"><pre><span></span><span class="o">&gt;</span> <span class="n">nm</span> <span class="n">vmlinux</span> <span class="o">&gt;</span> <span class="n">tmp</span><span class="p">;</span> <span class="n">grep</span> <span class="n">__log_buf</span> <span class="n">tmp</span><span class="p">;</span>
<span class="n">c000000000f5e3dc</span> <span class="n">b</span> <span class="n">__log_buf</span>
</pre></div>


<p>We use the nm tool to list all the kernel symbols and output this into some
temporary file, we can then grep this for the log buffer (which we know to be
named __log_buf), and presto we are told that it's at kernel address 0xf5e3dc.</p>
<h4>Dumping Guest Memory</h4>
<p>It's then simply a case of dumping guest memory from the QEMU console. So first
we press ^a+c to get us to the QEMU console, then we can use the aptly named
dump-guest-memory.</p>
<div class="highlight"><pre><span></span><span class="o">&gt;</span> <span class="n">help</span> <span class="n">dump</span><span class="o">-</span><span class="n">guest</span><span class="o">-</span><span class="n">memory</span>
<span class="n">dump</span><span class="o">-</span><span class="n">guest</span><span class="o">-</span><span class="n">memory</span> <span class="p">[</span><span class="o">-</span><span class="n">p</span><span class="p">]</span> <span class="p">[</span><span class="o">-</span><span class="n">d</span><span class="p">]</span> <span class="p">[</span><span class="o">-</span><span class="n">z</span><span class="o">|-</span><span class="n">l</span><span class="o">|-</span><span class="n">s</span><span class="p">]</span> <span class="n">filename</span> <span class="p">[</span><span class="n">begin</span> <span class="n">length</span><span class="p">]</span> <span class="o">--</span> <span class="n">dump</span> <span class="n">guest</span> <span class="n">memory</span> <span class="n">into</span> <span class="n">file</span> <span class="err">&#39;</span><span class="n">filename</span><span class="err">&#39;</span><span class="p">.</span>
            <span class="o">-</span><span class="nl">p</span><span class="p">:</span> <span class="k">do</span> <span class="n">paging</span> <span class="n">to</span> <span class="n">get</span> <span class="n">guest</span><span class="err">&#39;</span><span class="n">s</span> <span class="n">memory</span> <span class="n">mapping</span><span class="p">.</span>
            <span class="o">-</span><span class="nl">d</span><span class="p">:</span> <span class="k">return</span> <span class="n">immediately</span> <span class="p">(</span><span class="k">do</span> <span class="n">not</span> <span class="n">wait</span> <span class="k">for</span> <span class="n">completion</span><span class="p">).</span>
            <span class="o">-</span><span class="nl">z</span><span class="p">:</span> <span class="n">dump</span> <span class="n">in</span> <span class="n">kdump</span><span class="o">-</span><span class="n">compressed</span> <span class="n">format</span><span class="p">,</span> <span class="n">with</span> <span class="n">zlib</span> <span class="n">compression</span><span class="p">.</span>
            <span class="o">-</span><span class="nl">l</span><span class="p">:</span> <span class="n">dump</span> <span class="n">in</span> <span class="n">kdump</span><span class="o">-</span><span class="n">compressed</span> <span class="n">format</span><span class="p">,</span> <span class="n">with</span> <span class="n">lzo</span> <span class="n">compression</span><span class="p">.</span>
            <span class="o">-</span><span class="nl">s</span><span class="p">:</span> <span class="n">dump</span> <span class="n">in</span> <span class="n">kdump</span><span class="o">-</span><span class="n">compressed</span> <span class="n">format</span><span class="p">,</span> <span class="n">with</span> <span class="n">snappy</span> <span class="n">compression</span><span class="p">.</span>
            <span class="nl">begin</span><span class="p">:</span> <span class="n">the</span> <span class="n">starting</span> <span class="n">physical</span> <span class="n">address</span><span class="p">.</span>
            <span class="nl">length</span><span class="p">:</span> <span class="n">the</span> <span class="n">memory</span> <span class="n">size</span><span class="p">,</span> <span class="n">in</span> <span class="n">bytes</span><span class="p">.</span>
</pre></div>


<p>We just give it a filename for where we want our output to go, we know the
starting address, we just don't know the length. We could choose some arbitrary
length, but inspection of the kernel code shows us that:</p>
<div class="highlight"><pre><span></span><span class="cp">#define __LOG_BUF_LEN (1 &lt;&lt; CONFIG_LOG_BUF_SHIFT)</span>
<span class="k">static</span> <span class="kt">char</span> <span class="n">__log_buf</span><span class="p">[</span><span class="n">__LOG_BUF_LEN</span><span class="p">]</span> <span class="n">__aligned</span><span class="p">(</span><span class="n">LOG_ALIGN</span><span class="p">);</span>
</pre></div>


<p>Looking at the pseries_defconfig file shows us that the LOG_BUF_SHIFT is set to
18, and thus we know that the buffer is 2^18 bytes or 256kb. So now we run:</p>
<div class="highlight"><pre><span></span><span class="o">&gt;</span> <span class="n">dump</span><span class="o">-</span><span class="n">guest</span><span class="o">-</span><span class="n">memory</span> <span class="n">tmp</span> <span class="mh">0xf5e3dc</span> <span class="mi">262144</span>
</pre></div>


<p>And we now get our log buffer in the file tmp. This can simply be viewed with:</p>
<div class="highlight"><pre><span></span><span class="o">&gt;</span> <span class="n">hexdump</span> <span class="o">-</span><span class="n">C</span> <span class="n">tmp</span>
</pre></div>


<p>This gives a readable, if poorly formatted output. I'm sure you can find
something better but I'll leave that as an exercise for the reader.</p>
<h1>Conclusion</h1>
<p>So if like me your kernel hangs somewhere early in the boot process and you're
left without your console output you are now fully equipped to extract the log
buffer in QEMU and hopefully therein lies the answer to why you failed to boot.</p></div>
  		</article>
  		<article>
<header>
      <h1 class="entry-title">
        <a href="https://sthbrx.github.io/blog/2017/01/30/installing-centos-72-on-ibm-power-systems-s822lc-for-high-performance-computing-minksy-with-usb-device/">Installing Centos 7.2 on IBM Power System's S822LC for High Performance Computing (Minksy) with USB device</a>
      </h1>
    <p class="meta">
<time datetime="2017-01-30T08:54:33+11:00" pubdate>Mon 30 January 2017</time>    </p>
</header>

<div class="byline_index">
  <span class="byline author vcard">
    Posted by <span class="fn">
        <a href="https://sthbrx.github.io/author/daniel-black.html">Daniel Black</a>
    </span>
  </span>
<time datetime="2017-01-30T08:54:33+11:00" pubdate>Mon 30 January 2017</time></div>

  <div class="entry-content"><h2>Introduction</h2>
<p>If you are installing Linux on your IBM Power System's S822LC server then the instructions in this article will help you to start and run your system.  These instructions are specific to installing CentOS 7 on an IBM Power System S822LC for High Performance Computing (Minsky).</p>
<h3>Prerequisites</h3>
<p>Before you power on the system, ensure that you have the following items:</p>
<ul>
<li>Ethernet cables;</li>
<li>USB storage device of 7G or greater;</li>
<li>An installed ethernet network with a DHCP server;</li>
<li>Access to the DHCP server's logs;</li>
<li>Power cords and outlet for your system;</li>
<li>PC or notebook that has IPMItool level 1.8.15 or greater; and </li>
<li>a VNC client.</li>
</ul>
<p>Download CentOS ISO file from the <a href="http://mirror.centos.org/altarch/7/isos/ppc64le/">Centos Mirror</a>. Select the "Everything" ISO file.</p>
<p>Note: You must use the 1611 release (dated 2016-12-22) or later due to Linux Kernel support for the server hardware.</p>
<h2>Step 1: Preparing to power on your system</h2>
<p>Follow these steps to prepare your system:</p>
<ol>
<li>If your system belongs in a rack, install your system into that rack. For instructions, see IBM POWER8 Systems information.</li>
<li>Connect an Ethernet cable to the left embedded Ethernet port next to the serial port on the back of your system and the other end to your network. This Ethernet port is used for the BMC/IPMI interface.</li>
<li>Connect another Enternet cable to the right Ethernet port for network connection for the operating system.</li>
<li>Connect the power cords to the system and plug them into the outlets. </li>
</ol>
<p>At this point, your firmware is booting.</p>
<h2>Step 2: Determining the BMC firmware IP address</h2>
<p>To determine the IP address of the BMC, examine the latest DHCP server logs for the network connected to the server. The IP address will be requested approximately 2 minutes after being powered on.</p>
<p>It is possible to set the BMC to a static IP address by following the <a href="https://www.ibm.com/support/knowledgecenter/en/TI0003H/p8eih/p8eih_managing_with_ipmi_ami.htm">IBM documentation on IPMI</a>.</p>
<h2>Step 3: Connecting to the BMC firmware with IPMItool</h2>
<p>After you have a network connection set up for your BMC firmware, you can connect using Intelligent Platform Management Interface (IPMI).  IPMI is the default console to use when connecting to the Open Power Abstraction Layer (OPAL) firmware.</p>
<p>Use the default authentication for servers over IPMI is:</p>
<ul>
<li>Default user: ADMIN </li>
<li>Default password: admin </li>
</ul>
<p>To power on your server from a PC or notebook that is running Linux®, follow these steps:</p>
<p>Open a terminal program on your PC or notebook with <a href="#active-sol-ipmi">Activate Serial-Over-Lan using IPMI</a>. Use other steps here as needed.</p>
<p>For the following impitool commands, server_ip_address is the IP address of the BMC from Step 2, and ipmi_user and ipmi_password are the default user ID and password for IPMI.</p>
<h3>Power On using IPMI</h3>
<p>If your server is not powered on, run the following command to power the server on:</p>
<div class="highlight"><pre><span></span>ipmitool -I lanplus -H server_ip_address -U ipmi_user -P ipmi_password chassis power on
</pre></div>


<h3><a name="active-sol-ipmi"></a>Activate Serial-Over-Lan using IPMI</h3>
<p>Activate your IPMI console by running this command:</p>
<div class="highlight"><pre><span></span>ipmitool -I lanplus -H server_ip_address -U ipmi_user -P ipmi_password sol activate
</pre></div>


<p>After powering on your system, the Petitboot interface loads. If you do not interrupt the boot process by pressing any key within 10 seconds, Petitboot automatically boots the first option. At this point the IPMI console will be connected to the Operating Systems serial. If you get to this stage accidently you can deactivate and reboot as per the following two commands.</p>
<h3>Deactivate Serial-Over-Lan using IPMI</h3>
<p>If you need to power off or reboot your system, deactivate the console by running this command:</p>
<div class="highlight"><pre><span></span>ipmitool -I lanplus -H server_ip_address -U user-name -P ipmi_password sol deactivate
</pre></div>


<h3>Reboot using IPMI</h3>
<p>If you need to reboot the system, run this command: </p>
<div class="highlight"><pre><span></span>ipmitool -I lanplus -H server_ip_address -U user-name -P ipmi_password chassis power reset
</pre></div>


<h2>Step 4: Creating a USB device and booting</h2>
<p>At this point, your IPMI console should be contain a Petitboot bootloader menu as illistrated below and you are ready to install Centos 7 on your server.</p>
<p><img alt="Petitboot menu over IPMI" src="/images/centos7-minsky/petitboot-centos7-usb-topmenu.png" /> </p>
<p>Use one of the following USB devices:</p>
<ul>
<li>USB attached DVD player with a single USB cable to stay under 1.0 Amps, or</li>
<li>7 GB (or more) 2.0 (or later) USB flash drive. </li>
</ul>
<p>Follow the following instructions:</p>
<ol>
<li>To create the bootable USB device, follow the instructions in the CentOS wiki <a href="https://wiki.centos.org/HowTos/InstallFromUSBkey">Host to Set Up a USB to Install CentOS</a>.</li>
<li>Insert your bootable USB device into the front USB port. CentOS AltArch installer will automatically appear as a boot option on the Petitboot main screen. If the USB device does not appear select <em>Rescan devices</em>. If your device is not detected, you might have to try a different type.</li>
<li>Arrow up to select the CentOS boot option. Press <em>e</em> (Edit) to open the Petitboot Option Editor window</li>
<li>Move the cursor to the Boot arguments section and to include the following information: <code>ro inst.stage2=hd:LABEL=CentOS_7_ppc64le:/ console=hvc0 ip=dhcp</code></li>
</ol>
<p><img alt="Petitboot edited &quot;Install CentOS AltArch 7 (64-bit kernel)" src="/images/centos7-minsky/petitboot-centos7-usb-option-editor-menu.png" /></p>
<p>Notes about the boot arguments:   </p>
<ul>
<li><code>ip=dhcp</code> to ensure network is started for VNC installation.</li>
<li><code>console hvc0</code> is needed as this is not the default.</li>
<li><code>inst.stage2</code> is needed as the boot process won't automatically find the stage2 install on the install disk.</li>
<li>append <code>inst.proxy=URL</code> where URL is the proxy URL if installing in a network that requires a proxy to connect externally.</li>
</ul>
<p>You can find additional options at <a href="https://rhinstaller.github.io/anaconda/boot-options.html">Anaconda Boot Options</a>.</p>
<ol>
<li>Select <em>OK</em> to save your options and return to the Main menu </li>
<li>On the Petitboot main screen, select the CentOS AltArch option and then press <em>Enter</em>. </li>
</ol>
<h2>Step 5: Complete your installation</h2>
<p>After you select to boot the CentOS installer, the installer wizard walks you through the steps.  </p>
<ol>
<li>If the CentOS installer was able to obtain a network address via DHCP, it will present an option to enable the VNC. If no option is presented check your network cables. <img alt="VNC option" src="/images/centos7-minsky/anaconda-centos7-text-start.png" /></li>
<li>Select the <em>Start VNC</em> option and it will provide an OS server IP adress. Note that this will be different to the BMC address previously optained. <img alt="VNC option selected" src="/images/centos7-minsky/anaconda-centos7-vnc-selected.png" /></li>
<li>Run a VNC client program on your PC or notebook and connect to the OS server IP address.</li>
</ol>
<p><img alt="VNC of Installer" src="/images/centos7-minsky/anaconda-centos7-vnc-start.png" /></p>
<p>During the install over VNC, there are a couple of consoles active. To switch between them in the ipmitool terminal, press <em>ctrl-b</em> and then between <em>1</em>-<em>4</em> as indicated.</p>
<p>Using the VNC client program:</p>
<ol>
<li>Select "Install Destination"</li>
<li>Select a device from "Local Standard Disks"</li>
<li>Select "Full disk summary and boot device"</li>
<li>Select the device again from "Selected Disks" with the Boot enabled</li>
<li>Select "Do not install boot loader" from device. <img alt="Disabling install of boot loader" src="/images/centos7-minsky/anaconda-centos7-vnc-installation-destination-do-not-install-boot-loader.png" /> which results in <img alt="Result after disabling boot loader install" src="/images/centos7-minsky/anaconda-centos7-vnc-installation-destination-do-not-install-boot-loader-result.png" />.</li>
</ol>
<p>Without disabling boot loader, the installer complains about <code>an invalid stage1 device</code>. I suspect it needs a manual Prep partition of 10M to make the installer happy.</p>
<p>If you have a local Centos repository  you can set this by selecting "Install Source" - the directories at this url should look like <a href="http://mirror.centos.org/altarch/7/os/ppc64le/">CentOS's Install Source for ppc64le</a>.</p>
<h2>Step 6: Before reboot and using the IPMI Serial-Over-LAN</h2>
<p>Before reboot, generate the grub.cfg file as Petitboot uses this to generate its boot menu: </p>
<ol>
<li>Using the ipmitool's shell (<em>ctrl-b 2</em>):</li>
<li>Enter the following commands to generate a grub.cfg file</li>
</ol>
<div class="highlight"><pre><span></span>chroot /mnt/sysimage
rm /etc/grub.d/30_os-prober
grub2-mkconfig -o /boot/grub2/grub.cfg
exit
</pre></div>


<p><code>/etc/grub.d/30_os-prober</code> is removed as Petitboot probes the other devices anyway so including it would create lots of duplicate menu items.</p>
<p>The last step is to restart your system.</p>
<p>Note: While your system is restarting, remove the USB device. </p>
<p>After the system restarts, Petitboot displays the option to boot CentOS 7.2. Select this option and press Enter. </p>
<h2>Conclusion</h2>
<p>After you have booted CentOS, your server is ready to go!
For more information, see the following resources:</p>
<ul>
<li><a href="https://www.ibm.com/support/knowledgecenter/">IBM Knowledge Center</a></li>
<li><a href="https://www.ibm.com/developerworks/community/groups/service/html/communityview?communityUuid=fe313521-2e95-46f2-817d-44a4f27eba32">The Linux on Power Community</a></li>
<li><a href="https://developer.ibm.com/linuxonpower/category/announcements/">The Linux on Power Developer Center</a></li>
<li><a href="https://twitter.com/ibmpowerlinux">Follow us @ibmpowerlinux</a></li>
</ul></div>
  		</article>
  		<article>
<header>
      <h1 class="entry-title">
        <a href="https://sthbrx.github.io/blog/2016/08/17/getting-in-sync/">Getting In Sync</a>
      </h1>
    <p class="meta">
<time datetime="2016-08-17T15:23:00+10:00" pubdate>Wed 17 August 2016</time>    </p>
</header>

<div class="byline_index">
  <span class="byline author vcard">
    Posted by <span class="fn">
        <a href="https://sthbrx.github.io/author/samuel-mendoza-jonas.html">Samuel Mendoza-Jonas</a>
    </span>
  </span>
<time datetime="2016-08-17T15:23:00+10:00" pubdate>Wed 17 August 2016</time></div>

  <div class="entry-content"><p>Since at least v1.0.0 Petitboot has used device-mapper snapshots to avoid
mounting block devices directly. Primarily this is so Petitboot can mount disks
and potentially perform filesystem recovery without worrying about messing it up
and corrupting a host's boot partition - all changes happen to the snapshot in
memory without affecting the actual device.</p>
<p>This of course gets in the way if you actually <em>do</em> want to make changes to a
block device. Petitboot will allow certain bootloader scripts to make changes
to disks if configured (eg, grubenv updates), but if you manually make changes
you would need to know the special sequence of <code>dmsetup</code> commands to merge the
snapshots back to disk. This is particulary annoying if you're trying to copy
logs to a USB device!</p>
<p>Depending on how recent a version of Petitboot you're running, there are two
ways of making sure your changes persist:</p>
<h2>Before v1.2.2</h2>
<p>If you really need to save changes from within Petitboot, the most
straightforward way is to disable snapshots. Drop to the shell and enter</p>
<div class="highlight"><pre><span></span>nvram --update-config petitboot,snapshots?=false
reboot
</pre></div>


<p>Once you have rebooted you can remount the device as read-write and
modify it as normal.</p>
<h2>After v1.2.2</h2>
<p>To make this easier while keeping the benefit of snapshots, v1.2.2 introduces
a new user-event that will merge snapshots on demand. For example:</p>
<div class="highlight"><pre><span></span>mount -o remount,rw /var/petitboot/mnt/dev/sda2
cp /var/log/messages /var/petitboot/mnt/dev/sda2/
pb-event sync@sda2
</pre></div>


<p>After calling <code>pb-event sync@yourdevice</code>, Petitboot will remount the device back to
read-only and merge the current snapshot differences back to disk. You can also
run <code>pb-event sync@all</code> to sync all existing snapshots if desired.</p></div>
  		</article>
  		<article>
<header>
      <h1 class="entry-title">
        <a href="https://sthbrx.github.io/blog/2016/07/27/get-off-my-lawn-separating-docker-workloads-using-cgroups/">Get off my lawn: separating Docker workloads using cgroups</a>
      </h1>
    <p class="meta">
<time datetime="2016-07-27T13:30:00+10:00" pubdate>Wed 27 July 2016</time>    </p>
</header>

<div class="byline_index">
  <span class="byline author vcard">
    Posted by <span class="fn">
        <a href="https://sthbrx.github.io/author/daniel-axtens.html">Daniel Axtens</a>
    </span>
  </span>
<time datetime="2016-07-27T13:30:00+10:00" pubdate>Wed 27 July 2016</time></div>

  <div class="entry-content"><p>On my team, we do two different things in our Continuous Integration setup: build/functional tests, and performance tests. Build tests simply test whether a project builds, and, if the project provides a functional test suite, that the tests pass. We do a lot of MySQL/MariaDB testing this way. The other type of testing we do is performance tests: we build a project and then run a set of benchmarks against it. Python is a good example here.</p>
<p>Build tests want as much grunt as possible. Performance tests, on the other hand, want a stable, isolated environment. Initially, we set up Jenkins so that performance and build tests never ran at the same time. Builds would get the entire machine, and performance tests would never have to share with anyone.</p>
<p>This, while simple and effective, has some downsides. In POWER land, our machines are quite beefy. For example, one of the boxes I use - an S822L - has 4 sockets, each with 4 cores. At SMT-8 (an 8 way split of each core) that gives us 4 x 4 x 8 = 128 threads. It seems wasteful to lock this entire machine - all 128 threads - just so as to isolate a single-threaded test.<sup id="fnref:1"><a class="footnote-ref" href="#fn:1" rel="footnote">1</a></sup></p>
<p>So, <strong>can we partition our machine so that we can be running two different sorts of processes in a sufficiently isolated way?</strong></p>
<p>What counts as 'sufficiently isolated'? Well, my performance tests are CPU bound, so I want CPU isolation. I also want memory, and in particular memory bandwith to be isolated. I don't particularly care about IO isolation as my tests aren't IO heavy. Lastly, I have a couple of tests that are very multithreaded, so I'd like to have enough of a machine for those test results to be interesting.</p>
<p>For CPU isolation we have CPU affinity. We can also do something similar with memory. On a POWER8 system, memory is connected to individual P8s, not to some central point. This is a 'Non-Uniform Memory Architecture' (NUMA) setup: the directly attached memory will be very fast for a processor to access, and memory attached to other processors will be slower to access. An accessible guide (with very helpful diagrams!) is <a href="http://www.redbooks.ibm.com/redpapers/pdfs/redp5098.pdf">the relevant RedBook (PDF)</a>, chapter 2.</p>
<p>We could achieve the isolation we want by dividing up CPUs and NUMA nodes between the competing workloads. Fortunately, all of the hardware NUMA information is plumbed nicely into Linux. Each P8 socket gets a corresponding NUMA node. <code>lscpu</code> will tell you what CPUs correspond to which NUMA nodes (although what it calls a CPU we would call a hardware thread). If you install <code>numactl</code>, you can use <code>numactl -H</code> to get even more details.</p>
<p>In our case, the relevant <code>lscpu</code> output is thus:</p>
<div class="highlight"><pre><span></span>NUMA node0 CPU(s):     0-31
NUMA node1 CPU(s):     96-127
NUMA node16 CPU(s):    32-63
NUMA node17 CPU(s):    64-95
</pre></div>


<p>Now all we have to do is find some way to tell Linux to restrict a group of processes to a particular NUMA node and the corresponding CPUs. How? Enter control groups, or <code>cgroups</code> for short. Processes can be put into a cgroup, and then a cgroup controller can control the resouces allocated to the cgroup. Cgroups are hierarchical, and there are controllers for a number of different ways you could control a group of processes. Most helpfully for us, there's one called <code>cpuset</code>, which can control CPU affinity, and restrict memory allocation to a NUMA node.</p>
<p>We then just have to get the processes into the relevant cgroup. Fortunately, Docker is incredibly helpful for this!<sup id="fnref:2"><a class="footnote-ref" href="#fn:2" rel="footnote">2</a></sup> Docker containers are put in the <code>docker</code> cgroup. Each container gets it's own cgroup under the docker cgroup, and fortunately Docker deals well with the somewhat broken state of cpuset inheritance.<sup id="fnref:3"><a class="footnote-ref" href="#fn:3" rel="footnote">3</a></sup> So it suffices to create a cpuset cgroup for docker, and allocate some resources to it, and Docker will do the rest. Here we'll allocate the last 3 sockets and NUMA nodes to Docker containers:</p>
<div class="highlight"><pre><span></span>cgcreate -g cpuset:docker
<span class="nb">echo</span> 32-127 &gt; /sys/fs/cgroup/cpuset/docker/cpuset.cpus
<span class="nb">echo</span> 1,16-17 &gt; /sys/fs/cgroup/cpuset/docker/cpuset.mems
<span class="nb">echo</span> <span class="m">1</span> &gt; /sys/fs/cgroup/cpuset/docker/cpuset.mem_hardwall
</pre></div>


<p><code>mem_hardwall</code> prevents memory allocations under docker from spilling over into the one remaining NUMA node.</p>
<p>So, does this work? I created a container with sysbench and then ran the following:</p>
<div class="highlight"><pre><span></span>root@0d3f339d4181:/# sysbench --test<span class="o">=</span>cpu --num-threads<span class="o">=</span><span class="m">128</span> --max-requests<span class="o">=</span><span class="m">10000000</span> run
</pre></div>


<p>Now I've asked for 128 threads, but the cgroup only has CPUs/hwthreads 32-127 allocated. So If I run htop, I shouldn't see any load on CPUs 0-31. What do I actually see?</p>
<p><img alt="htop screenshot, showing load only on CPUs 32-127" src="/images/dja/cgroup1.png" /></p>
<p>It works! Now, we create a cgroup for performance tests using the first socket and NUMA node:</p>
<div class="highlight"><pre><span></span>cgcreate -g cpuset:perf-cgroup
<span class="nb">echo</span> 0-31 &gt; /sys/fs/cgroup/cpuset/perf-cgroup/cpuset.cpus
<span class="nb">echo</span> <span class="m">0</span> &gt; /sys/fs/cgroup/cpuset/perf-cgroup/cpuset.mems
<span class="nb">echo</span> <span class="m">1</span> &gt; /sys/fs/cgroup/cpuset/perf-cgroup/cpuset.mem_hardwall
</pre></div>


<p>Docker conveniently lets us put new containers under a different cgroup, which means we can simply do:</p>
<div class="highlight"><pre><span></span>dja@p88 ~&gt; docker run -it --rm --cgroup-parent<span class="o">=</span>/perf-cgroup/ ppc64le/ubuntu bash
root@b037049f94de:/# <span class="c1"># ... install sysbench</span>
root@b037049f94de:/# sysbench --test<span class="o">=</span>cpu --num-threads<span class="o">=</span><span class="m">128</span> --max-requests<span class="o">=</span><span class="m">10000000</span> run
</pre></div>


<p>And the result?</p>
<p><img alt="htop screenshot, showing load only on CPUs 0-31" src="/images/dja/cgroup2.png" /></p>
<p>It works! My benchmark results also suggest this is sufficient isolation, and the rest of the team is happy to have more build resources to play with.</p>
<p>There are some boring loose ends to tie up: if a build job does anything outside of docker (like clone a git repo), that doesn't come under the docker cgroup, and we have to interact with systemd. Because systemd doesn't know about cpuset, this is <em>quite</em> fiddly. We also want this in a systemd unit so it runs on start up, and we want some code to tear it down. But I'll spare you the gory details.</p>
<p>In summary, cgroups are surprisingly powerful and simple to work with, especially in conjunction with Docker and NUMA on Power!</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p>It gets worse! Before the performance test starts, all the running build jobs must drain. If we have 8 Jenkins executors running on the box, and a performance test job is the next in the queue, we have to wait for 8 running jobs to clear. If they all started at different times and have different runtimes, we will inevitably spend a fair chunk of time with the machine at less than full utilisation while we're waiting.&#160;<a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:2">
<p>At least, on Ubuntu 16.04. I haven't tested if this is true anywhere else.&#160;<a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:3">
<p>I hear this is getting better. It is also why systemd hasn't done cpuset inheritance yet.&#160;<a class="footnote-backref" href="#fnref:3" rev="footnote" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
</ol>
</div></div>
  		</article>
  		<article>
<header>
      <h1 class="entry-title">
        <a href="https://sthbrx.github.io/blog/2016/07/06/where-to-get-a-power8-development-vm/">Where to Get a POWER8 Development VM</a>
      </h1>
    <p class="meta">
<time datetime="2016-07-06T16:00:00+10:00" pubdate>Wed 06 July 2016</time>    </p>
</header>

<div class="byline_index">
  <span class="byline author vcard">
    Posted by <span class="fn">
        <a href="https://sthbrx.github.io/author/andrew-donnellan.html">Andrew Donnellan</a>
    </span>
  </span>
<time datetime="2016-07-06T16:00:00+10:00" pubdate>Wed 06 July 2016</time></div>

  <div class="entry-content"><p><em>POWER8 sounds great, but where the heck can I get a Power VM so I can test my code?</em></p>
<p>This is a common question we get at OzLabs from other open source developers looking to port their software to the Power Architecture. Unfortunately, most developers don't have one of our amazing servers just sitting around under their desk.</p>
<p>Thankfully, there's a few IBM partners who offer free VMs for development use. If you're in need of a development VM, check out:</p>
<ul>
<li><a href="http://openpower.ic.unicamp.br/minicloud/">MiniCloud</a>, hosted by the State University of Campinas (Unicamp), Brazil</li>
<li><a href="http://osuosl.org/services/powerdev">OSU Open Source Lab</a>, hosted by the Oregon State University</li>
<li><a href="https://ptopenlab.com/cloudlabconsole">SuperVessel Cloud for Power/OpenPOWER</a>, hosted by IBM China</li>
</ul>
<p>So, next time you wonder how you can test your project on POWER8, request a VM and get to it!</p></div>
  		</article>
<div class="pagination">
    <a class="prev" href="https://sthbrx.github.io/index2.html">&larr; Older</a>

  <br />
</div></div>
<aside class="sidebar">
  <section>
    <h1>Recent Posts</h1>
    <ul id="recent_posts">
      <li class="post">
          <a href="https://sthbrx.github.io/blog/2017/01/30/extracting-early-boot-messages-in-qemu/">Extracting Early Boot Messages in QEMU</a>
      </li>
      <li class="post">
          <a href="https://sthbrx.github.io/blog/2017/01/30/installing-centos-72-on-ibm-power-systems-s822lc-for-high-performance-computing-minksy-with-usb-device/">Installing Centos 7.2 on IBM Power System's S822LC for High Performance Computing (Minksy) with USB device</a>
      </li>
      <li class="post">
          <a href="https://sthbrx.github.io/blog/2016/08/17/getting-in-sync/">Getting In Sync</a>
      </li>
      <li class="post">
          <a href="https://sthbrx.github.io/blog/2016/07/27/get-off-my-lawn-separating-docker-workloads-using-cgroups/">Get off my lawn: separating Docker workloads using cgroups</a>
      </li>
      <li class="post">
          <a href="https://sthbrx.github.io/blog/2016/07/06/where-to-get-a-power8-development-vm/">Where to Get a POWER8 Development VM</a>
      </li>
    </ul>
  </section>
  <section>
      
    <h1>Categories</h1>
    <ul id="recent_posts">
        <li><a href="https://sthbrx.github.io/category/development.html">Development</a></li>
        <li><a href="https://sthbrx.github.io/category/docker.html">Docker</a></li>
        <li><a href="https://sthbrx.github.io/category/education.html">Education</a></li>
        <li><a href="https://sthbrx.github.io/category/education-qemu-virtualisation.html">Education, QEMU, Virtualisation</a></li>
        <li><a href="https://sthbrx.github.io/category/openpower.html">OpenPOWER</a></li>
        <li><a href="https://sthbrx.github.io/category/petitboot.html">Petitboot</a></li>
        <li><a href="https://sthbrx.github.io/category/snowpatch.html">snowpatch</a></li>
    </ul>
  </section>
 

  <section>
  <h1>Tags</h1>
    <a href="https://sthbrx.github.io/tag/kernel.html">kernel</a>,    <a href="https://sthbrx.github.io/tag/centos.html">centos</a>,    <a href="https://sthbrx.github.io/tag/debugging.html">debugging</a>,    <a href="https://sthbrx.github.io/tag/skiroot.html">skiroot</a>,    <a href="https://sthbrx.github.io/tag/hex.html">hex</a>,    <a href="https://sthbrx.github.io/tag/work-experience.html">work experience</a>,    <a href="https://sthbrx.github.io/tag/intern.html">intern</a>,    <a href="https://sthbrx.github.io/tag/skiboot.html">skiboot</a>,    <a href="https://sthbrx.github.io/tag/opal.html">OPAL</a>,    <a href="https://sthbrx.github.io/tag/printk.html">printk</a>,    <a href="https://sthbrx.github.io/tag/education.html">Education</a>,    <a href="https://sthbrx.github.io/tag/qemu.html">QEMU</a>,    <a href="https://sthbrx.github.io/tag/p8.html">p8</a>,    <a href="https://sthbrx.github.io/tag/pxe.html">pxe</a>,    <a href="https://sthbrx.github.io/tag/linux-gods.html">Linux Gods</a>,    <a href="https://sthbrx.github.io/tag/virtualisation.html">virtualisation</a>,    <a href="https://sthbrx.github.io/tag/aufs.html">aufs</a>,    <a href="https://sthbrx.github.io/tag/cgroups.html">cgroups</a>,    <a href="https://sthbrx.github.io/tag/patches.html">patches</a>,    <a href="https://sthbrx.github.io/tag/conferences.html">conferences</a>,    <a href="https://sthbrx.github.io/tag/overlay.html">overlay</a>,    <a href="https://sthbrx.github.io/tag/peformance.html">peformance</a>,    <a href="https://sthbrx.github.io/tag/tools.html">tools</a>,    <a href="https://sthbrx.github.io/tag/based16.html">based16</a>,    <a href="https://sthbrx.github.io/tag/boot.html">boot</a>,    <a href="https://sthbrx.github.io/tag/centos7.html">centos7</a>,    <a href="https://sthbrx.github.io/tag/vdso.html">vdso</a>,    <a href="https://sthbrx.github.io/tag/mitigation.html">mitigation</a>,    <a href="https://sthbrx.github.io/tag/offtopic.html">offtopic</a>,    <a href="https://sthbrx.github.io/tag/petitboot.html">petitboot</a>,    <a href="https://sthbrx.github.io/tag/hpc.html">hpc</a>,    <a href="https://sthbrx.github.io/tag/performance.html">performance</a>,    <a href="https://sthbrx.github.io/tag/srop.html">SROP</a>,    <a href="https://sthbrx.github.io/tag/development.html">Development</a>,    <a href="https://sthbrx.github.io/tag/bmc.html">bmc</a>,    <a href="https://sthbrx.github.io/tag/float.html">float</a>,    <a href="https://sthbrx.github.io/tag/ipmi.html">ipmi</a>,    <a href="https://sthbrx.github.io/tag/early.html">early</a>,    <a href="https://sthbrx.github.io/tag/debug.html">debug</a>,    <a href="https://sthbrx.github.io/tag/numa.html">numa</a>,    <a href="https://sthbrx.github.io/tag/realcontent.html">realcontent</a>,    <a href="https://sthbrx.github.io/tag/php.html">php</a>,    <a href="https://sthbrx.github.io/tag/snowpatch.html">snowpatch</a>,    <a href="https://sthbrx.github.io/tag/asm.html">asm</a>,    <a href="https://sthbrx.github.io/tag/dmesg.html">dmesg</a>,    <a href="https://sthbrx.github.io/tag/ozlabs.html">Ozlabs</a>,    <a href="https://sthbrx.github.io/tag/netboot.html">netboot</a>,    <a href="https://sthbrx.github.io/tag/s822lc-for-hpc.html">S822LC for hpc</a>,    <a href="https://sthbrx.github.io/tag/kexec.html">kexec</a>,    <a href="https://sthbrx.github.io/tag/double.html">double</a>,    <a href="https://sthbrx.github.io/tag/fsp.html">FSP</a>,    <a href="https://sthbrx.github.io/tag/autoboot.html">autoboot</a>,    <a href="https://sthbrx.github.io/tag/error.html">error</a>,    <a href="https://sthbrx.github.io/tag/lvm.html">lvm</a>,    <a href="https://sthbrx.github.io/tag/devmapper.html">devmapper</a>,    <a href="https://sthbrx.github.io/tag/goodposts.html">goodposts</a>,    <a href="https://sthbrx.github.io/tag/capi.html">capi</a>  </section>


    <section>
        <h1>Social</h1>
        <ul>
            <li><a href="https://sthbrx.github.io/rss.xml" type="application/rss+xml" rel="alternate">RSS</a></li>
            <li><a href="https://github.com/sthbrx/" target="_blank">GitHub</a></li>
            <li><a href="https://lists.ozlabs.org/listinfo/linuxppc-dev" target="_blank">linuxppc mailing list</a></li>
            <li><a href="https://lists.ozlabs.org/listinfo/skiboot" target="_blank">Skiboot mailing list</a></li>
        </ul>
    </section>
    <section>
        <h1>Blogroll</h1>
        <ul>
            <li><a href="http://ozlabs.org" target="_blank">OzLabs</a></li>
        </ul>
    </section>

    <section>
        <h1>Disclaimer</h1>
        <div>
This blog represents the views of the individual authors, and doesn't necessarily represent IBM's positions, strategies or opinions.        </div>
    </section>
</aside>    </div>
  </div>
  <footer role="contentinfo"><p>
    Copyright &copy;  2015&ndash;2017  OzLabs &mdash;
  <span class="credit">Powered by <a href="http://getpelican.com">Pelican</a></span>
</p></footer>
  <script src="https://sthbrx.github.io/theme/js/modernizr-2.0.js"></script>
  <script src="https://sthbrx.github.io/theme/js/ender.js"></script>
  <script src="https://sthbrx.github.io/theme/js/octopress.js" type="text/javascript"></script>
  <script type="text/javascript">
    var disqus_shortname = 'sthbrx';
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = "//" + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
     })();
  </script>
</body>
</html>