<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  <title>Store Half Byte-Reverse Indexed</title>
  <meta name="author" content="OzLabs">

  <link href="https://sthbrx.github.io/rss.xml" type="application/rss+xml" rel="alternate"
        title="Store Half Byte-Reverse Indexed RSS Feed" />



  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">


    <link href="https://sthbrx.github.io/favicon.png" rel="icon">

  <link href="https://sthbrx.github.io/theme/css/main.css" media="screen, projection"
        rel="stylesheet" type="text/css">

  <link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic"
        rel="stylesheet" type="text/css">
  <link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic"
        rel="stylesheet" type="text/css">

  <script type="text/javascript">
document.addEventListener('DOMContentLoaded', function() {
  var ts = document.createElement('span')
  ts.className = 'toggle-sidebar'
  ts = document.getElementById('content').appendChild(ts);
  ts.addEventListener('click', function(e) {
    e.preventDefault();
    body = document.getElementsByTagName('body')[0];
    bodyClasses = body.classList.toggle('collapse-sidebar');
  });
  var sections = document.querySelectorAll('aside.sidebar > section');
  if (sections.length > 1) {
    for (index = 0; index < sections.length; index++) {
      section = sections[index];
      if ((sections.length >= 3) && index % 3 === 0) {
        section.classList.add("first");
      }
      var count = ((index +1) % 2) ? "odd" : "even";
      section.classList.add(count);
    }
  }
  if (sections.length >= 3) {
    document.querySelector('aside.sidebar').classList.add('thirds');
  }
});
  </script>
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-91189608-1', 'auto');

    ga('send', 'pageview');
    </script>
</head>

<body>
  <header role="banner"><hgroup>
  <h1><a href="https://sthbrx.github.io/">Store Half Byte-Reverse Indexed</a></h1>
    <h2>A Power Technical Blog</h2>
</hgroup></header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="https://sthbrx.github.io/rss.xml" rel="subscribe-rss">RSS</a></li>
</ul>


<ul class="main-navigation">
      <li >
        <a href="https://sthbrx.github.io/category/development.html">Development</a>
      </li>
      <li >
        <a href="https://sthbrx.github.io/category/docker.html">Docker</a>
      </li>
      <li >
        <a href="https://sthbrx.github.io/category/education.html">Education</a>
      </li>
      <li >
        <a href="https://sthbrx.github.io/category/openpower.html">OpenPOWER</a>
      </li>
      <li >
        <a href="https://sthbrx.github.io/category/performance.html">Performance</a>
      </li>
      <li >
        <a href="https://sthbrx.github.io/category/petitboot.html">Petitboot</a>
      </li>
      <li >
        <a href="https://sthbrx.github.io/category/snowpatch.html">snowpatch</a>
      </li>
      <li >
        <a href="https://sthbrx.github.io/category/virtualisation-and-emulation.html">Virtualisation and Emulation</a>
      </li>
</ul></nav>
  <div id="main">
    <div id="content">
<div class="blog-index">
  		<article>
<header>
      <h1 class="entry-title">
        <a href="https://sthbrx.github.io/blog/2018/10/09/open-source-firmware-conference-2018/">Open Source Firmware Conference 2018</a>
      </h1>
    <p class="meta">
<time datetime="2018-10-09T10:08:00+11:00" pubdate>Tue 09 October 2018</time>    </p>
</header>

<div class="byline_index">
  <span class="byline author vcard">
    Posted by <span class="fn">
        <a href="https://sthbrx.github.io/author/samuel-mendoza-jonas.html">Samuel Mendoza-Jonas</a>
    </span>
  </span>
<time datetime="2018-10-09T10:08:00+11:00" pubdate>Tue 09 October 2018</time></div>

  <div class="entry-content"><p>I recently had the pleasure of attending the <a href="https://osfc.io">2018 Open Source Firmware Conference</a> in Erlangen, Germany. Compared to other more general conferences I've attended in the past, the laser focus of OSFC on firmware and especially firmware security was fascinating. Seeing developers from across the world coming together to discuss how they are improving their corner of the stack was great, and I've walked away with plenty of new knowledge and ideas (and several kilos of German food and drink..).</p>
<hr>
<p>What was especially exciting though is that I had the chance to talk about my work on <a href="https://github.com/open-power/petitboot">Petitboot</a> and what's happened from the POWER8 launch until now. If you're interested in that, or seeing how I talk after 36 hours of travel, check it out here:</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/8Z1vEinNU7I" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>

<hr>
<p>OSFC have made all the talks from the first two days available in a <a href="https://www.youtube.com/playlist?list=PLJ4u8GLmFVmoRCX_gFXV6fhWmsOQ5cmuj">playlist on Youtube</a><br>
If you're after a few suggestions there was, in no particular order:</p>
<p><a href="https://www.youtube.com/watch?v=ZjAu0VYRTno">Ryan O'Leary giving an update on Linuxboot</a> - also known as NERF, Google's approach to a Linux bootloader all written in Go.</p>
<p><a href="https://www.youtube.com/watch?v=qUgo-AVsSC">Subrate Banik talking about porting Coreboot on top of Intel's FSP</a></p>
<p><a href="https://www.youtube.com/watch?v=ukSh1n7wjSA">Ron Minnich describing his work with "rompayloads" on Coreboot</a></p>
<p><a href="https://www.youtube.com/watch?v=gC-lbMNmIsg">Vadmin Bendebury describing Google's "Secure Microcontroller" Chip</a></p>
<p><a href="https://www.youtube.com/watch?v=eKVSBESoKUc">Facebook presenting their use of Linuxboot and "systemboot"</a></p>
<p>And heaps more, check out the full playlist!</p></div>
  		</article>
  		<article>
<header>
      <h1 class="entry-title">
        <a href="https://sthbrx.github.io/blog/2018/08/15/improving-performance-of-phoronix-benchmarks-on-power9/">Improving performance of Phoronix benchmarks on POWER9</a>
      </h1>
    <p class="meta">
<time datetime="2018-08-15T14:22:00+10:00" pubdate>Wed 15 August 2018</time>    </p>
</header>

<div class="byline_index">
  <span class="byline author vcard">
    Posted by <span class="fn">
        <a href="https://sthbrx.github.io/author/rashmica-gupta.html">Rashmica Gupta</a>
    </span>
  </span>
<time datetime="2018-08-15T14:22:00+10:00" pubdate>Wed 15 August 2018</time></div>

  <div class="entry-content"><p>Recently Phoronix ran a range of
<a href="https://www.phoronix.com/scan.php?page=article&amp;item=power9-talos-2&amp;num=1">benchmarks</a>
comparing the performance of our POWER9 processor against the Intel Xeon and AMD
EPYC processors. </p>
<p>We did well in the Stockfish, LLVM Compilation, Zstd compression, and the
Tinymembench benchmarks. A few of my colleagues did a bit of investigating into
some the benchmarks where we didn't perform quite so well.</p>
<h3>LBM / Parboil</h3>
<p>The <a href="http://impact.crhc.illinois.edu/parboil/parboil.aspx">Parboil benchmarks</a> are a
collection of programs from various scientific and commercial fields that are
useful for examining the performance and development of different architectures
and tools.  In this round of benchmarks Phoronix used the lbm
<a href="https://www.spec.org/cpu2006/Docs/470.lbm.html">benchmark</a>: a fluid dynamics
simulation using the Lattice-Boltzmann Method.</p>
<p>lbm is an iterative algorithm - the problem is broken down into discrete
time steps, and at each time step a bunch of calculations are done to
simulate the change in the system. Each time step relies on the results
of the previous one.</p>
<p>The benchmark uses OpenMP to parallelise the workload, spreading the
calculations done in each time step across many CPUs. The number of
calculations scales with the resolution of the simulation.</p>
<p>Unfortunately, the resolution (and therefore the work done in each time
step) is too small for modern CPUs with large numbers of SMT (simultaneous multi-threading) threads. OpenMP 
doesn't have enough work to parallelise and the system stays relatively idle. This
means the benchmark scales relatively poorly, and is definitely
not making use of the large POWER9 system</p>
<p>Also this benchmark is compiled without any optimisation. Recompiling with -O3 improves the
   results 3.2x on POWER9.</p>
<h3>x264 Video Encoding</h3>
<p>x264 is a library that encodes videos into the H.264/MPEG-4 format. x264 encoding
requires a lot of integer kernels doing operations on image elements. The math
and vectorisation optimisations are quite complex, so Nick only had a quick look at
the basics. The systems and environments (e.g. gcc version 8.1 for Skylake, 8.0
for POWER9) are not completely apples to apples so for now patterns are more
important than the absolute results. Interestingly the output video files between
architectures are not the same, particularly with different asm routines and 
compiler options used, which makes it difficult to verify the correctness of any changes.</p>
<p>All tests were run single threaded to avoid any SMT effects.</p>
<p>With the default upstream build of x264, Skylake is significantly faster than POWER9 on this benchmark
(Skylake: 9.20 fps, POWER9: 3.39 fps). POWER9 contains some vectorised routines, so an
initial suspicion is that Skylake's larger vector size may be responsible for its higher throughput.</p>
<p>Let's test our vector size suspicion by restricting
Skylake to SSE4.2 code (with 128 bit vectors, the same width as POWER9). This hardly
slows down the x86 CPU at all (Skylake: 8.37 fps, POWER9: 3.39 fps), which indicates it's
not taking much advantage of the larger vectors.</p>
<p>So the next guess would be that x86 just has more and better optimized versions of costly
functions (in the version of x264 that Phoronix used there are only six powerpc specific
files compared with 21 x86 specific files). Without the time or expertise to dig into the
complex task of writing vector code, we'll see if the compiler can help, and turn
on autovectorisation (x264 compiles with -fno-tree-vectorize by default, which disables 
auto vectorization). Looking at a perf profile of the benchmark we can see
that one costly function, quant_4x4x4, is not autovectorised. With a small change to the
code, gcc does vectorise it, giving a slight speedup with the output file checksum unchanged
(Skylake: 9.20 fps, POWER9: 3.83 fps).</p>
<p>We got a small improvement with the compiler, but it looks like we may have gains left on the
table with our vector code. If you're interested in looking into this, we do have some
<a href="https://www.bountysource.com/teams/ibm/bounties">active bounties</a> for x264 (lu-zero/x264).</p>
<table>
<thead>
<tr>
<th>Test</th>
<th>Skylake</th>
<th>POWER9</th>
</tr>
</thead>
<tbody>
<tr>
<td>Original - AVX256</td>
<td>9.20 fps</td>
<td>3.39 fps</td>
</tr>
<tr>
<td>Original - SSE4.2</td>
<td>8.37 fps</td>
<td>3.39 fps</td>
</tr>
<tr>
<td>Autovectorisation enabled, quant_4x4x4 vectorised</td>
<td>9.20 fps</td>
<td>3.83 fps</td>
</tr>
</tbody>
</table>
<p>Nick also investigated running this benchmark with SMT enabled and across multiple cores, and it looks like the code is
not scalable enough to feed 176 threads on a 44 core system. Disabling SMT in parallel runs
actually helped, but there was still idle time. That may be another thing to look at,
although it may not be such a problem for smaller systems.</p>
<h3>Primesieve</h3>
<p><a href="https://primesieve.org/">Primesieve</a> is a program and C/C++
library that generates all the prime numbers below a given number. It uses an
optimised <a href="https://upload.wikimedia.org/wikipedia/commons/b/b9/Sieve_of_Eratosthenes_animation.gif">Sieve of Eratosthenes</a>
implementation.</p>
<p>The algorithm uses the L1 cache size as the sieve size for the core loop.  This
is an issue when we are running in SMT mode (aka more than one thread per core)
as all threads on a core share the same L1 cache and so will constantly be 
invalidating each others cache-lines. As you can see
in the table below, running the benchmark in single threaded mode is 30% faster
than in SMT4 mode!</p>
<p>This means in SMT-4 mode the workload is about 4x too large for the L1 cache.  A
better sieve size to use would be the L1 cache size / number of
threads per core. Anton posted a <a href="https://github.com/kimwalisch/primesieve/pull/54">pull request</a> 
to update the sieve size.</p>
<p>It is interesting that the best overall performance on POWER9 is with the patch applied and in
SMT2 mode:</p>
<table>
<thead>
<tr>
<th>SMT level</th>
<th>baseline</th>
<th>patched</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>14.728s</td>
<td>14.899s</td>
</tr>
<tr>
<td>2</td>
<td>15.362s</td>
<td>14.040s</td>
</tr>
<tr>
<td>4</td>
<td>19.489s</td>
<td>17.458s</td>
</tr>
</tbody>
</table>
<h3>LAME</h3>
<p>Despite its name, a recursive acronym for "LAME Ain't an MP3 Encoder",
<a href="http://lame.sourceforge.net/">LAME</a> is indeed an MP3 encoder.</p>
<p>Due to configure options <a href="https://sourceforge.net/p/lame/mailman/message/36371506/">not being parsed correctly</a> this
benchmark is built without any optimisation regardless of architecture. We see a
massive speedup by turning optimisations on, and a further 6-8% speedup by
enabling
<a href="https://sourceforge.net/p/lame/mailman/message/36372005/">USE_FAST_LOG</a> (which
is already enabled for Intel).</p>
<table>
<thead>
<tr>
<th>LAME</th>
<th>Duration</th>
<th>Speedup</th>
</tr>
</thead>
<tbody>
<tr>
<td>Default</td>
<td>82.1s</td>
<td>n/a</td>
</tr>
<tr>
<td>With optimisation flags</td>
<td>16.3s</td>
<td>5.0x</td>
</tr>
<tr>
<td>With optimisation flags and USE_FAST_LOG set</td>
<td>15.6s</td>
<td>5.3x</td>
</tr>
</tbody>
</table>
<p>For more detail see Joel's
<a href="https://shenki.github.io/LameMP3-on-Power9/">writeup</a>.</p>
<h3>FLAC</h3>
<p><a href="https://xiph.org/flac/">FLAC</a> is an alternative encoding format to
MP3. But unlike MP3 encoding it is lossless!  The benchmark here was encoding
audio files into the FLAC format. </p>
<p>The key part of this workload is missing
vector support for POWER8 and POWER9. Anton and Amitay submitted this
<a href="http://lists.xiph.org/pipermail/flac-dev/2018-July/006351.html">patch series</a> that
adds in POWER specific vector instructions. It also fixes the configuration options
to correctly detect the POWER8 and POWER9 platforms. With this patch series we get see about a 3x
improvement in this benchmark.</p>
<h3>OpenSSL</h3>
<p><a href="https://www.openssl.org/">OpenSSL</a> is among other things a cryptographic library. The Phoronix benchmark
measures the number of RSA 4096 signs per second:</p>
<div class="highlight"><pre><span></span>$ openssl speed -multi <span class="k">$(</span>nproc<span class="k">)</span> rsa4096
</pre></div>


<p>Phoronix used OpenSSL-1.1.0f, which is almost half as slow for this benchmark (on POWER9) than mainline OpenSSL.
Mainline OpenSSL has some powerpc multiplication and squaring assembly code which seems
to be responsible for most of this speedup.</p>
<p>To see this for yourself, add these four powerpc specific commits on top of OpenSSL-1.1.0f:</p>
<ol>
<li><a href="https://github.com/openssl/openssl/commit/b17ff188b17499e83ca3b9df0be47a2f513ac3c5">perlasm/ppc-xlate.pl: recognize .type directive</a></li>
<li><a href="https://github.com/openssl/openssl/commit/0310becc82d240288a4ab5c6656c10c18cab4454">bn/asm/ppc-mont.pl: prepare for extension</a></li>
<li><a href="https://github.com/openssl/openssl/commit/68f6d2a02c8cc30c5c737fc948b7cf023a234b47">bn/asm/ppc-mont.pl: add optimized multiplication and squaring subroutines</a></li>
<li><a href="https://github.com/openssl/openssl/commit/80d27cdb84985c697f8fabb7649abf1f54714d13">ppccap.c: engage new multipplication and squaring subroutines</a></li>
</ol>
<p>The following results were from a dual 16-core POWER9:</p>
<table>
<thead>
<tr>
<th>Version of OpenSSL</th>
<th>Signs/s</th>
<th>Speedup</th>
</tr>
</thead>
<tbody>
<tr>
<td>1.1.0f</td>
<td>1921</td>
<td>n/a</td>
</tr>
<tr>
<td>1.1.0f with 4 patches</td>
<td>3353</td>
<td>1.74x</td>
</tr>
<tr>
<td>1.1.1-pre1</td>
<td>3383</td>
<td>1.76x</td>
</tr>
</tbody>
</table>
<h3>SciKit-Learn</h3>
<p><a href="http://scikit-learn.org/">SciKit-Learn</a> is a bunch of python tools for data mining and
analysis (aka machine learning).</p>
<p>Joel noticed that the benchmark spent 92% of the time in libblas. Libblas is a
very basic BLAS (basic linear algebra subprograms) library that python-numpy
uses to do vector and matrix operations.  The default libblas on Ubuntu is only
compiled with -O2. Compiling with -Ofast and using alternative BLAS's that have
powerpc optimisations (such as libatlas or libopenblas) we see big improvements
in this benchmark:</p>
<table>
<thead>
<tr>
<th>BLAS used</th>
<th>Duration</th>
<th>Speedup</th>
</tr>
</thead>
<tbody>
<tr>
<td>libblas -O2</td>
<td>64.2s</td>
<td>n/a</td>
</tr>
<tr>
<td>libblas -Ofast</td>
<td>36.1s</td>
<td>1.8x</td>
</tr>
<tr>
<td>libatlas</td>
<td>8.3s</td>
<td>7.7x</td>
</tr>
<tr>
<td>libopenblas</td>
<td>4.2s</td>
<td>15.3x</td>
</tr>
</tbody>
</table>
<p>You can read more details about this
<a href="https://shenki.github.io/Scikit-Learn-on-Power9/">here</a>.</p>
<h3>Blender</h3>
<p><a href="https://www.blender.org/">Blender</a> is a 3D graphics suite that supports image rendering,
animation, simulation and game creation. On the surface it appears that Blender
2.79b (the distro package version that Phoronix used by system/blender-1.0.2)
failed to use more than 15 threads, even when "-t 128" was added to the Blender
command line.</p>
<p>It turns out that even though this benchmark was supposed to be run on CPUs only
(you can choose to render on CPUs or GPUs), the GPU file was always being used.
The GPU file is configured with a very large tile size (256x256) -
which is <a href="https://docs.blender.org/manual/en/dev/render/cycles/settings/scene/render/performance.html#tiles">fine for
GPUs</a>
but not great for CPUs. The image size (1280x720) to tile size ratio limits the
number of jobs created and therefore the number threads used.</p>
<p>To obtain a realistic CPU measurement with more that 15 threads you can force
the use of the CPU file by overwriting the GPU file with the CPU one:</p>
<div class="highlight"><pre><span></span>$ cp
~/.phoronix-test-suite/installed-tests/system/blender-1.0.2/benchmark/pabellon_barcelona/pavillon_barcelone_cpu.blend
~/.phoronix-test-suite/installed-tests/system/blender-1.0.2/benchmark/pabellon_barcelona/pavillon_barcelone_gpu.blend
</pre></div>


<p>As you can see in the image below, now all of the cores are being utilised!
<img alt="Blender with CPU Blend file" src="/images/phoronix/blender-88threads.png" title="Blender with CPU Blend file"></p>
<p>Fortunately this has already been fixed in 
<a href="https://openbenchmarking.org/test/pts/blender">pts/blender-1.1.1</a>.
Thanks to the <a href="https://github.com/phoronix-test-suite/test-profiles/issues/24">report</a> by Daniel it
has also been fixed in <a href="http://openbenchmarking.org/test/system/blender-1.1.0">system/blender-1.1.0</a>.</p>
<p>Pinning the pts/bender-1.0.2, Pabellon Barcelona, CPU-Only test to a single
22-core POWER9 chip (<code>sudo ppc64_cpu --cores-on=22</code>) and two POWER9 chips
(<code>sudo ppc64_cpu --cores-on=44</code>) show a huge speedup:</p>
<table>
<thead>
<tr>
<th>Benchmark</th>
<th>Duration (deviation over 3 runs)</th>
<th>Speedup</th>
</tr>
</thead>
<tbody>
<tr>
<td>Baseline (GPU blend file)</td>
<td>1509.97s (0.30%)</td>
<td>n/a</td>
</tr>
<tr>
<td>Single 22-core POWER9 chip (CPU blend file)</td>
<td>458.64s (0.19%)</td>
<td>3.29x</td>
</tr>
<tr>
<td>Two 22-core POWER9 chips (CPU blend file)</td>
<td>241.33s (0.25%)</td>
<td>6.25x</td>
</tr>
</tbody>
</table>
<h3>tl;dr</h3>
<p>Some of the benchmarks where we don't perform as well as Intel are where the
benchmark has inline assembly for x86 but uses generic C compiler generated
assembly for POWER9. We could probably benefit with some more powerpc optimsed functions.</p>
<p>We also found a couple of things that should result in better performance for all three architectures,
not just POWER.</p>
<p>A summary of the performance improvements we found:</p>
<table>
<thead>
<tr>
<th>Benchmark</th>
<th>Approximate Improvement</th>
</tr>
</thead>
<tbody>
<tr>
<td>Parboil</td>
<td>3x</td>
</tr>
<tr>
<td>x264</td>
<td>1.1x</td>
</tr>
<tr>
<td>Primesieve</td>
<td>1.1x</td>
</tr>
<tr>
<td>LAME</td>
<td>5x</td>
</tr>
<tr>
<td>FLAC</td>
<td>3x</td>
</tr>
<tr>
<td>OpenSSL</td>
<td>2x</td>
</tr>
<tr>
<td>SciKit-Learn</td>
<td>7-15x</td>
</tr>
<tr>
<td>Blender</td>
<td>3x</td>
</tr>
</tbody>
</table>
<p>There is obviously room for more improvements, especially with the Primesieve and x264 benchmarks,
but it would be interesting to see a re-run of the Phoronix benchmarks with these changes. </p>
<p>Thanks to Anton, Daniel, Joel and Nick for the analysis of the above benchmarks.</p></div>
  		</article>
  		<article>
<header>
      <h1 class="entry-title">
        <a href="https://sthbrx.github.io/blog/2017/09/23/stupid-solutions-to-stupid-problems-hardcoding-your-ssh-key-in-the-kernel/">Stupid Solutions to Stupid Problems: Hardcoding Your SSH Key in the Kernel</a>
      </h1>
    <p class="meta">
<time datetime="2017-09-23T03:00:00+10:00" pubdate>Sat 23 September 2017</time>    </p>
</header>

<div class="byline_index">
  <span class="byline author vcard">
    Posted by <span class="fn">
        <a href="https://sthbrx.github.io/author/andrew-donnellan.html">Andrew Donnellan</a>
    </span>
  </span>
<time datetime="2017-09-23T03:00:00+10:00" pubdate>Sat 23 September 2017</time></div>

  <div class="entry-content"><h2>The "problem"</h2>
<p>I'm currently working on firmware and kernel support for <a href="http://opencapi.org/">OpenCAPI</a> on POWER9.</p>
<p>I've recently been allocated a machine in the lab for development purposes. We use an internal IBM tool running on a secondary machine that triggers hardware initialisation procedures, then loads a specified <a href="https://github.com/open-power/skiboot">skiboot</a> firmware image, a kernel image, and a root file system directly into RAM. This allows us to get skiboot and Linux running without requiring the usual <a href="https://github.com/open-power/hostboot">hostboot</a> initialisation and gives us a lot of options for easier tinkering, so it's super-useful for our developers working on bringup.</p>
<p>When I got access to my machine, I figured out the necessary scripts, developed a workflow, and started fixing my code... so far, so good.</p>
<p>One day, I was trying to debug something and get logs off the machine using <code>ssh</code> and <code>scp</code>, when I got frustrated with having to repeatedly type in our ultra-secret, ultra-secure root password, <code>abc123</code>. So, I ran <code>ssh-copy-id</code> to copy over my public key, and all was good.</p>
<p>Until I rebooted the machine, when strangely, my key stopped working. It took me longer than it should have to realise that this is an obvious consequence of running entirely from an initrd that's reloaded every boot...</p>
<h2>The "solution"</h2>
<p>I mentioned something about this to Jono, my housemate/partner-in-stupid-ideas, one evening a few weeks ago. We decided that clearly, the best way to solve this problem was to hardcode my SSH public key in the kernel.</p>
<p>This would definitely be the easiest and most sensible way to solve the problem, as opposed to, say, just keeping my own copy of the root filesystem image. Or asking <a href="https://twitter.com/mikeyneuling">Mikey</a>, whose desk is three metres away from mine, whether he could use his write access to add my key to the image. Or just writing a wrapper around <a href="https://linux.die.net/man/1/sshpass">sshpass</a>...</p>
<p>One Tuesday afternoon, I was feeling bored...</p>
<h2>The approach</h2>
<p>The SSH daemon looks for authorised public keys in <code>~/.ssh/authorized_keys</code>, so we need to have a read of <code>/root/.ssh/authorized_keys</code> return a specified hard-coded string.</p>
<p>I did a bit of investigation. My first thought was to put some kind of hook inside whatever filesystem driver was being used for the root. After some digging, I found out that the filesystem type <code>rootfs</code>, as seen in <code>mount</code>, is actually backed by the <code>tmpfs</code> filesystem. I took a look around the <code>tmpfs</code> code for a while, but didn't see any way to hook in a fake file without a lot of effort - the <code>tmpfs</code> code wasn't exactly designed with this in mind.</p>
<p>I thought about it some more - what would be the easiest way to create a file such that it just returns a string?</p>
<p>Then I remembered sysfs, the filesystem normally mounted at <code>/sys</code>, which is used by various kernel subsystems to expose configuration and debugging information to userspace in the form of files. The sysfs API allows you to define a file and specify callbacks to handle reads and writes to the file.</p>
<p>That got me thinking - could I create a file in <code>/sys</code>, and then use a <a href="https://unix.stackexchange.com/questions/198590/what-is-a-bind-mount">bind mount</a> to have that file appear where I need it in <code>/root/.ssh/authorized_keys</code>? This approach seemed fairly straightforward, so I decided to give it a try.</p>
<p>First up, creating a pseudo-file. It had been a while since the last time I'd used the sysfs API...</p>
<h2>sysfs</h2>
<p>The sysfs pseudo file system was first introduced in Linux 2.6, and is generally used for exposing system and device information.</p>
<p>Per the <a href="https://www.kernel.org/doc/Documentation/filesystems/sysfs.txt">sysfs documentation</a>, sysfs is tied in very closely with the <a href="https://www.kernel.org/doc/Documentation/kobject.txt">kobject</a> infrastructure. sysfs exposes kobjects as directories, containing "attributes" represented as files. The kobject infrastructure provides a way to define kobjects representing entities (e.g. devices) and ksets which define collections of kobjects (e.g. devices of a particular type).</p>
<p>Using kobjects you can do lots of fancy things such as sending events to userspace when devices are hotplugged - but that's all out of the scope of this post. It turns out there's some fairly straightforward wrapper functions if all you want to do is create a kobject just to have a simple directory in sysfs.</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/kobject.h&gt;</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">ssh_key_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">ssh_kobj</span><span class="p">;</span>
        <span class="n">ssh_kobj</span> <span class="o">=</span> <span class="n">kobject_create_and_add</span><span class="p">(</span><span class="s">&quot;ssh&quot;</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ssh_kobj</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;SSH: kobject creation failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
                <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
        <span class="p">}</span>
<span class="p">}</span>
<span class="n">late_initcall</span><span class="p">(</span><span class="n">ssh_key_init</span><span class="p">);</span>
</pre></div>


<p>This creates and adds a kobject called <code>ssh</code>. And just like that, we've got a directory in <code>/sys/ssh/</code>!</p>
<p>The next thing we have to do is define a sysfs attribute for our <code>authorized_keys</code> file. sysfs provides a framework for subsystems to define their own custom types of attributes with their own metadata - but for our purposes, we'll use the generic <code>bin_attribute</code> attribute type.</p>
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;linux/sysfs.h&gt;</span><span class="cp"></span>

<span class="k">const</span> <span class="kt">char</span> <span class="n">key</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;PUBLIC KEY HERE...&quot;</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">show_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kobject</span> <span class="o">*</span><span class="n">kobj</span><span class="p">,</span>
                        <span class="k">struct</span> <span class="n">bin_attribute</span> <span class="o">*</span><span class="n">bin_attr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span>
                        <span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">return</span> <span class="n">memory_read_from_buffer</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pos</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">bin_attr</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">bin_attribute</span> <span class="n">authorized_keys_attr</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">attr</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;authorized_keys&quot;</span><span class="p">,</span> <span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="mo">0444</span> <span class="p">},</span>
        <span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">show_key</span><span class="p">,</span>
        <span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
<span class="p">};</span>
</pre></div>


<p>We provide a simple callback, <code>show_key()</code>, that copies the key string into the file's buffer, and we put it in a <code>bin_attribute</code> with the appropriate name, size and permissions.</p>
<p>To actually add the attribute, we put the following in <code>ssh_key_init()</code>:</p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
<span class="n">rc</span> <span class="o">=</span> <span class="n">sysfs_create_bin_file</span><span class="p">(</span><span class="n">ssh_kobj</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">authorized_keys_attr</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;SSH: sysfs creation failed, rc %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>Woo, we've now got <code>/sys/ssh/authorized_keys</code>! Time to move on to the bind mount.</p>
<h2>Mounting</h2>
<p>Now that we've got a directory with the key file in it, it's time to figure out the bind mount.</p>
<p>Because I had no idea how any of the file system code works, I started off by running <code>strace</code> on <code>mount --bind ~/tmp1 ~/tmp2</code> just to see how the userspace <code>mount</code> tool uses the <code>mount</code> syscall to request the bind mount.</p>
<div class="highlight"><pre><span></span><span class="n">execve</span><span class="p">(</span><span class="s">&quot;/bin/mount&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s">&quot;mount&quot;</span><span class="p">,</span> <span class="s">&quot;--bind&quot;</span><span class="p">,</span> <span class="s">&quot;/home/ajd/tmp1&quot;</span><span class="p">,</span> <span class="s">&quot;/home/ajd/tmp2&quot;</span><span class="p">],</span> <span class="p">[</span><span class="cm">/* 18 vars */</span><span class="p">])</span> <span class="o">=</span> <span class="mi">0</span>

<span class="p">...</span>

<span class="n">mount</span><span class="p">(</span><span class="s">&quot;/home/ajd/tmp1&quot;</span><span class="p">,</span> <span class="s">&quot;/home/ajd/tmp2&quot;</span><span class="p">,</span> <span class="mh">0x18b78bf00</span><span class="p">,</span> <span class="n">MS_MGC_VAL</span><span class="o">|</span><span class="n">MS_BIND</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>


<p>The first and second arguments are the source and target paths respectively. The third argument, looking at the signature of the <code>mount</code> syscall, is a pointer to a string with the file system type. Because this is a bind mount, the type is irrelevant (upon further digging, it turns out that this particular pointer is to the string "none").</p>
<p>The fourth argument is where we specify the flags bitfield. <code>MS_MGC_VAL</code> is a magic value that was required before Linux 2.4 and can now be safely ignored. <code>MS_BIND</code>, as you can probably guess, signals that we want a bind mount.</p>
<p>(The final argument is used to pass file system specific data - as you can see it's ignored here.)</p>
<p>Now, how is the syscall actually handled on the kernel side? The answer is found in <a href="http://elixir.free-electrons.com/linux/latest/source/fs/namespace.c#L2969">fs/namespace.c</a>.</p>
<div class="highlight"><pre><span></span><span class="n">SYSCALL_DEFINE5</span><span class="p">(</span><span class="n">mount</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">dir_name</span><span class="p">,</span>
                <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

        <span class="cm">/* ... copy parameters from userspace memory ... */</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="n">do_mount</span><span class="p">(</span><span class="n">kernel_dev</span><span class="p">,</span> <span class="n">dir_name</span><span class="p">,</span> <span class="n">kernel_type</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">options</span><span class="p">);</span>

        <span class="cm">/* ... cleanup ... */</span>
<span class="p">}</span>
</pre></div>


<p>So in order to achieve the same thing from within the kernel, we just call <code>do_mount()</code> with exactly the same parameters as the syscall uses:</p>
<div class="highlight"><pre><span></span><span class="n">rc</span> <span class="o">=</span> <span class="n">do_mount</span><span class="p">(</span><span class="s">&quot;/sys/ssh&quot;</span><span class="p">,</span> <span class="s">&quot;/root/.ssh&quot;</span><span class="p">,</span> <span class="s">&quot;sysfs&quot;</span><span class="p">,</span> <span class="n">MS_BIND</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;SSH: bind mount failed, rc %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>...and we're done, right? Not so fast:</p>
<div class="highlight"><pre><span></span><span class="n">SSH</span><span class="o">:</span> <span class="n">bind</span> <span class="n">mount</span> <span class="n">failed</span><span class="o">,</span> <span class="n">rc</span> <span class="o">-</span><span class="mi">2</span>
</pre></div>


<p>-2 is <code>ENOENT</code> - no such file or directory. For some reason, we can't find <code>/sys/ssh</code>... of course, that would be because even though we've created the sysfs entry, we haven't actually mounted sysfs on <code>/sys</code>.</p>
<div class="highlight"><pre><span></span><span class="n">rc</span> <span class="o">=</span> <span class="n">do_mount</span><span class="p">(</span><span class="s">&quot;sysfs&quot;</span><span class="p">,</span> <span class="s">&quot;/sys&quot;</span><span class="p">,</span> <span class="s">&quot;sysfs&quot;</span><span class="p">,</span>
              <span class="n">MS_NOSUID</span> <span class="o">|</span> <span class="n">MS_NOEXEC</span> <span class="o">|</span> <span class="n">MS_NODEV</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</pre></div>


<p>At this point, my key worked!</p>
<p>Note that this requires that your root file system has an empty directory created at <code>/sys</code> to be the mount point. Additionally, in a typical Linux distribution environment (as opposed to my hardware bringup environment), your initial root file system will contain an init script that mounts your real root file system somewhere and calls <code>pivot_root()</code> to switch to the new root file system. At that point, the bind mount won't be visible from children processes using the new root - I think this could be worked around but would require some effort.</p>
<h2>Kconfig</h2>
<p>The final piece of the puzzle is building our new code into the kernel image.</p>
<p>To allow us to switch this important functionality on and off, I added a config option to <code>fs/Kconfig</code>:</p>
<div class="highlight"><pre><span></span>config SSH_KEY
        bool &quot;Andrew&#39;s dumb SSH key hack&quot;
        default y
        help
          Hardcode an SSH key for /root/.ssh/authorized_keys.

          This is a stupid idea. If unsure, say N.
</pre></div>


<p>This will show up in <code>make menuconfig</code> under the <code>File systems</code> menu.</p>
<p>And in <code>fs/Makefile</code>:</p>
<div class="highlight"><pre><span></span><span class="nv">obj-$(CONFIG_SSH_KEY)</span>           <span class="o">+=</span> ssh_key.o
</pre></div>


<p>If <code>CONFIG_SSH_KEY</code> is set to <code>y</code>, <code>obj-$(CONFIG_SSH_KEY)</code> evaluates to <code>obj-y</code> and thus <code>ssh-key.o</code> gets compiled. Conversely, <code>obj-n</code> is completely ignored by the build system.</p>
<p>I thought I was all done... then <a href="https://twitter.com/mramboar">Andrew</a> suggested I make the contents of the key configurable, and I had to oblige. Conveniently, Kconfig options can also be strings:</p>
<div class="highlight"><pre><span></span>config SSH_KEY_VALUE
        string &quot;Value for SSH key&quot;
        depends on SSH_KEY
        help
          Enter in the content for /root/.ssh/authorized_keys.
</pre></div>


<p>Including the string in the C file is as simple as:</p>
<div class="highlight"><pre><span></span><span class="k">const</span> <span class="kt">char</span> <span class="n">key</span><span class="p">[]</span> <span class="o">=</span> <span class="n">CONFIG_SSH_KEY_VALUE</span><span class="p">;</span>
</pre></div>


<p>And there we have it, a nicely configurable albeit highly limited kernel SSH backdoor!</p>
<h2>Conclusion</h2>
<p>I've put the <a href="https://github.com/ajdlinux/linux/commit/052c0cb7296f7510fd482fecbe572b641c29239f">full code</a> up on GitHub for perusal. Please don't use it, I will be extremely disappointed in you if you do.</p>
<p>Thanks to Jono for giving me stupid ideas, and the rest of OzLabs for being very angry when they saw the disgusting things I was doing.</p>
<p>Comments and further stupid suggestions welcome!</p></div>
  		</article>
  		<article>
<header>
      <h1 class="entry-title">
        <a href="https://sthbrx.github.io/blog/2017/09/22/ncsi-nice-network-youve-got-there/">NCSI - Nice Network You've Got There</a>
      </h1>
    <p class="meta">
<time datetime="2017-09-22T10:08:00+10:00" pubdate>Fri 22 September 2017</time>    </p>
</header>

<div class="byline_index">
  <span class="byline author vcard">
    Posted by <span class="fn">
        <a href="https://sthbrx.github.io/author/samuel-mendoza-jonas.html">Samuel Mendoza-Jonas</a>
    </span>
  </span>
<time datetime="2017-09-22T10:08:00+10:00" pubdate>Fri 22 September 2017</time></div>

  <div class="entry-content"><p>A neat piece of kernel code dropped into my lap recently, and as a way of
processing having to inject an entire network stack into by brain in
less-than-ideal time I thought we'd have a look at it here: NCSI!</p>
<h2>NCSI - Not the TV Show</h2>
<p>NCSI stands for Network Controller Sideband Interface, and put most simply it
is a way for a management controller (eg. a BMC like those found on our OpenPOWER
machines) to share a single physical network interface with a host machine.
Instead of two distinct network interfaces you plug in a single cable and both
the host and the BMC have network connectivity.</p>
<p>NCSI-capable network controllers achieve this by filtering network traffic as
it arrives and determining if it is host- or BMC-bound. To know how to do this
the BMC needs to tell the network controller what to look out for, and from a
Linux driver perspective this the focus of the NCSI protocol.</p>
<p><img alt="NCSI Overview" src="/images/sammj/ncsi_overview.png"></p>
<h2>Hi My Name Is 70:e2:84:14:24:a1</h2>
<p>The major components of what NCSI helps facilitate are:</p>
<ul>
<li>Network Controllers, known as 'Packages' in this context. There may be multiple
  separate packages which contain one or more Channels.</li>
<li>Channels, most easily thought of as the individual physical network interfaces.
  If a package is the network card, channels are the individual network jacks. (Somewhere a pedant's head is spinning in circles).</li>
<li>Management Controllers, or our BMC, with their own network interfaces. Hypothetically there can be multiple
  management controllers in a single NCSI system, but I've not come across such
  a setup yet.</li>
</ul>
<p>NCSI is the medium and protocol via which these components communicate.</p>
<p><img alt="NCSI Packages" src="/images/sammj/ncsi_packages.png"></p>
<p>The interface between Management Controller and one or more
Packages carries both general network traffic to/from the Management
Controller as well as NCSI traffic between the Management Controller
and the Packages &amp; Channels. Management traffic is differentiated from
regular traffic via the inclusion of a special NCSI tag inserted
in the Ethernet frame header.
These management commands are used to discover and configure the state of the
NCSI packages and channels.</p>
<p>If a BMC's network interface is configured to use NCSI, as soon as the interface
is brought up NCSI gets to work finding and configuring a usable channel.
The NCSI driver at first glance is an intimidating combination of state machines
and packet handlers, but with enough coffee it can be represented like this:</p>
<p><img alt="NCSI State Diagram" src="/images/sammj/ncsi_states.png"></p>
<p>Without getting into the nitty gritty details the overall process for configuring
a channel enough to get packets flowing is fairly straightforward:</p>
<ul>
<li>Find available packages.</li>
<li>Find each package's available channels.</li>
<li>(At least in the Linux driver) select a channel with link.</li>
<li>Put this channel into the Initial Config State.
The Initial Config State is where all the useful configuration occurs. Here we
find out what the selected channel is capable of and its current configuration,
and set it up to recognise the traffic we're interested in. The first and most
basic way of doing this is configuring the channel to filter traffic based on
our MAC address.</li>
<li>Enable the channel and let the packets flow.</li>
</ul>
<p>At this point NCSI takes a back seat to normal network traffic, transmitting
a "Get Link Status" packet at regular intervals to monitor the channel.</p>
<h2>AEN Packets</h2>
<p>Changes can occur from the package side too; the NCSI package communicates these
back to the BMC with Asynchronous Event Notification (AEN) packets. As the name
suggests these can occur at any time and the driver needs to catch and handle these.
There are different types but they essentially boil down to changes in link state,
telling the BMC the channel needs to be reconfigured, or to select a different
channel.
These are only transmitted once and no effort is made to recover lost AEN packets -
another good reason for the NCSI driver to periodically monitor the channel.</p>
<h2>Filtering</h2>
<p>Each channel can be configured to filter traffic based on MAC address,
broadcast traffic, multicast traffic, and VLAN tagging. Associated with each of
these filters is a <em>filter table</em> which can hold a finite number of entries.
In the case of the VLAN filter each channel could match against 15 different
VLAN IDs for example, but in practice the physical device will likely
support less. Indeed the popular BCM5718 controller supports only two!</p>
<p>This is where I dived into NCSI. The driver had a lot of the pieces for
configuring VLAN filters but none of it was actually hooked up in the configure
state, and didn't have a way of actually knowing which VLAN IDs were meant to be
configured on the interface. The bulk of that work appears in <a href="https://github.com/torvalds/linux/commit/21acf63013ed3d6fce3176cc34b74064052a31b4#diff-f391518f4e552724349be3589e00dfa7">this commit</a> where we take advantage of some useful network stack callbacks to get the VLAN configuration and set them during the configuration state. Getting <em>to</em> the configuration state at some arbitrary time and then managing to assign multiple IDs was the trickiest bit, and is something I'll be looking at simplifying in the future.</p>
<hr>
<p>NCSI! A neat way to give physically separate users access to a single network controller, and if it works right you won't notice it at all. I'll surely be spending more time here (fleshing out the driver's features, better error handling, and making the state machine a touch more readable to start, and I haven't even <em>mentioned</em> HWA), so watch this space!</p></div>
  		</article>
  		<article>
<header>
      <h1 class="entry-title">
        <a href="https://sthbrx.github.io/blog/2017/09/01/memcmp-for-power8-part-ii/">memcmp() for POWER8 - part II</a>
      </h1>
    <p class="meta">
<time datetime="2017-09-01T12:00:00+10:00" pubdate>Fri 01 September 2017</time>    </p>
</header>

<div class="byline_index">
  <span class="byline author vcard">
    Posted by <span class="fn">
        <a href="https://sthbrx.github.io/author/cyril-bur.html">Cyril Bur</a>
    </span>
  </span>
<time datetime="2017-09-01T12:00:00+10:00" pubdate>Fri 01 September 2017</time></div>

  <div class="entry-content"><p>This entry is a followup to part I which you should absolutely read
<a href="https://sthbrx.github.io/blog/2017/08/07/memcmp-for-power8/">here</a> before continuing
on.</p>
<h2>Where we left off</h2>
<p>We concluded that while a vectorised <code>memcmp()</code> is a win, there are
some cases where it won't quite perform.</p>
<h2>The overhead of enabling ALTIVEC</h2>
<p>In the kernel we explicitly don't touch ALTIVEC unless we need to,
this means that in the general case we can leave the userspace
registers in place and not have do anything to service a syscall for a
process.</p>
<p>This means that if we do want to use ALTIVEC in the kernel, there is
some setup that must be done. Notably, we must enable the facility (a
potentially time consuming move to MSR), save off the registers (if
userspace we using them) and an inevitable restore later on.</p>
<p>If all this needs to be done for a <code>memcmp()</code> in the order of tens of
bytes then it really wasn't worth it.</p>
<p>There are two reasons that <code>memcmp()</code> might go for a small number of
bytes, firstly and trivially detectable is simply that parameter n is
small. The other is harder to detect, if the memcmp() is going to fail
(return non zero) early then it also wasn't worth enabling ALTIVEC.</p>
<h2>Detecting early failures</h2>
<p>Right at the start of <code>memcmp()</code>, before enabling ALTIVEC, the first
64 bytes are checked using general purpose registers. Why the first 64
bytes, well why not? In a strange twist of fate 64 bytes happens to be
the amount of bytes in four ALTIVEC registers (128 bits per register,
so 16 bytes multiplied by 4) and by utter coincidence that happens to
be the stride of the ALTIVEC compare loop.</p>
<h2>What does this all look like</h2>
<p>Well unlike part I the results appear slightly less consistent across
three runs of measurement but there are some very key differences with
part I. The trends do appear to be the same across all three runs,
just less pronounced - why this is is unclear.</p>
<p>The difference between run two and run three clipped at deltas of
1000ns is interesting:
<img alt="Sample 2: Deltas below 1000ns" src="/images/power8_memcmp/v2deltas2-1000.png" title="Sample 2: Deltas below 1000ns"></p>
<p>vs</p>
<p><img alt="Sample 3: Deltas below 1000ns" src="/images/power8_memcmp/v2deltas3-1000.png" title="Sample 3: Deltas below 1000ns"></p>
<p>The results are similar except for a spike in the amount of deltas in
the unpatched kernel at around 600ns. This is not present in the first
sample (deltas1) of data. There are a number of reasons why this spike
could have appeared here, it is possible that the kernel or hardware
did something under the hood, prefetch could have brought deltas for a
<code>memcmp()</code> that would otherwise have yielded a greater delta into the
600ns range.</p>
<p>What these two graphs do both demonstrate quite clearly is that
optimisations down at the sub 100ns end have resulted in more sub
100ns deltas for the patched kernel, a significant win over the
original data. Zooming out and looking at a graph which includes
deltas up to 5000ns shows that the sub 100ns delta optimisations
haven't noticeably slowed the performance of long duration <code>memcmp()</code>,
<img alt="Samply 2: Deltas below 5000ns" src="/images/power8_memcmp/v2deltas2-5000.png" title="Sample 2: Deltas below 5000ns">.</p>
<h2>Conclusion</h2>
<p>The small amount of extra development effort has yielded tangible
results in reducing the low end <code>memcmp()</code> times. This second round of
data collection and performance analysis only confirms the that for
any significant amount of comparison, a vectorised loop is
significantly quicker.</p>
<p>The results obtained here show no downside to adopting this approach
for all power8 and onwards chips as this new version of the patch
solves the performance regression for small compares.</p></div>
  		</article>
<div class="pagination">
    <a class="prev" href="https://sthbrx.github.io/index2.html">&larr; Older</a>

  <br />
</div></div>
<aside class="sidebar">
  <section>
    <h1>Recent Posts</h1>
    <ul id="recent_posts">
      <li class="post">
          <a href="https://sthbrx.github.io/blog/2018/10/09/open-source-firmware-conference-2018/">Open Source Firmware Conference 2018</a>
      </li>
      <li class="post">
          <a href="https://sthbrx.github.io/blog/2018/08/15/improving-performance-of-phoronix-benchmarks-on-power9/">Improving performance of Phoronix benchmarks on POWER9</a>
      </li>
      <li class="post">
          <a href="https://sthbrx.github.io/blog/2017/09/23/stupid-solutions-to-stupid-problems-hardcoding-your-ssh-key-in-the-kernel/">Stupid Solutions to Stupid Problems: Hardcoding Your SSH Key in the Kernel</a>
      </li>
      <li class="post">
          <a href="https://sthbrx.github.io/blog/2017/09/22/ncsi-nice-network-youve-got-there/">NCSI - Nice Network You've Got There</a>
      </li>
      <li class="post">
          <a href="https://sthbrx.github.io/blog/2017/09/01/memcmp-for-power8-part-ii/">memcmp() for POWER8 - part II</a>
      </li>
    </ul>
  </section>
  <section>
      
    <h1>Categories</h1>
    <ul id="recent_posts">
        <li><a href="https://sthbrx.github.io/category/development.html">Development</a></li>
        <li><a href="https://sthbrx.github.io/category/docker.html">Docker</a></li>
        <li><a href="https://sthbrx.github.io/category/education.html">Education</a></li>
        <li><a href="https://sthbrx.github.io/category/openpower.html">OpenPOWER</a></li>
        <li><a href="https://sthbrx.github.io/category/performance.html">Performance</a></li>
        <li><a href="https://sthbrx.github.io/category/petitboot.html">Petitboot</a></li>
        <li><a href="https://sthbrx.github.io/category/snowpatch.html">snowpatch</a></li>
        <li><a href="https://sthbrx.github.io/category/virtualisation-and-emulation.html">Virtualisation and Emulation</a></li>
    </ul>
  </section>
 

  <section>
  <h1>Tags</h1>
    <a href="https://sthbrx.github.io/tag/linux.html">linux</a>,    <a href="https://sthbrx.github.io/tag/firmware.html">firmware</a>,    <a href="https://sthbrx.github.io/tag/security.html">security</a>,    <a href="https://sthbrx.github.io/tag/goodposts.html">goodposts</a>,    <a href="https://sthbrx.github.io/tag/realcontent.html">realcontent</a>,    <a href="https://sthbrx.github.io/tag/sparseposting.html">sparseposting</a>,    <a href="https://sthbrx.github.io/tag/openpower.html">openpower</a>,    <a href="https://sthbrx.github.io/tag/openbmc.html">openbmc</a>,    <a href="https://sthbrx.github.io/tag/easyposts.html">easyposts</a>,    <a href="https://sthbrx.github.io/tag/linuxboot.html">linuxboot</a>,    <a href="https://sthbrx.github.io/tag/google.html">google</a>,    <a href="https://sthbrx.github.io/tag/intel.html">intel</a>,    <a href="https://sthbrx.github.io/tag/osfc.html">osfc</a>,    <a href="https://sthbrx.github.io/tag/shortposts.html">shortposts</a>,    <a href="https://sthbrx.github.io/tag/facebook.html">facebook</a>,    <a href="https://sthbrx.github.io/tag/performance.html">performance</a>,    <a href="https://sthbrx.github.io/tag/phoronix.html">phoronix</a>,    <a href="https://sthbrx.github.io/tag/benchmarks.html">benchmarks</a>,    <a href="https://sthbrx.github.io/tag/kernel.html">kernel</a>,    <a href="https://sthbrx.github.io/tag/stupid-ideas.html">stupid ideas</a>,    <a href="https://sthbrx.github.io/tag/network.html">network</a>,    <a href="https://sthbrx.github.io/tag/power.html">power</a>,    <a href="https://sthbrx.github.io/tag/xdp.html">xdp</a>,    <a href="https://sthbrx.github.io/tag/networking.html">networking</a>,    <a href="https://sthbrx.github.io/tag/remoteposts.html">remoteposts</a>,    <a href="https://sthbrx.github.io/tag/ceph.html">ceph</a>,    <a href="https://sthbrx.github.io/tag/raid.html">raid</a>,    <a href="https://sthbrx.github.io/tag/storage.html">storage</a>,    <a href="https://sthbrx.github.io/tag/erasure.html">erasure</a>,    <a href="https://sthbrx.github.io/tag/lustre.html">lustre</a>,    <a href="https://sthbrx.github.io/tag/hpc.html">hpc</a>,    <a href="https://sthbrx.github.io/tag/nvlink.html">nvlink</a>,    <a href="https://sthbrx.github.io/tag/namd.html">namd</a>,    <a href="https://sthbrx.github.io/tag/cuda.html">cuda</a>,    <a href="https://sthbrx.github.io/tag/gpu.html">gpu</a>,    <a href="https://sthbrx.github.io/tag/minsky.html">minsky</a>,    <a href="https://sthbrx.github.io/tag/s822lc-for-hpc.html">S822LC for hpc</a>,    <a href="https://sthbrx.github.io/tag/conferences.html">conferences</a>,    <a href="https://sthbrx.github.io/tag/qemu.html">QEMU</a>,    <a href="https://sthbrx.github.io/tag/debug.html">debug</a>,    <a href="https://sthbrx.github.io/tag/virtualisation.html">virtualisation</a>,    <a href="https://sthbrx.github.io/tag/dmesg.html">dmesg</a>,    <a href="https://sthbrx.github.io/tag/printk.html">printk</a>,    <a href="https://sthbrx.github.io/tag/boot.html">boot</a>,    <a href="https://sthbrx.github.io/tag/early.html">early</a>,    <a href="https://sthbrx.github.io/tag/error.html">error</a>,    <a href="https://sthbrx.github.io/tag/centos.html">centos</a>,    <a href="https://sthbrx.github.io/tag/centos7.html">centos7</a>,    <a href="https://sthbrx.github.io/tag/p8.html">p8</a>,    <a href="https://sthbrx.github.io/tag/bmc.html">bmc</a>,    <a href="https://sthbrx.github.io/tag/rhel.html">RHEL</a>,    <a href="https://sthbrx.github.io/tag/skiroot.html">skiroot</a>,    <a href="https://sthbrx.github.io/tag/petitboot.html">petitboot</a>,    <a href="https://sthbrx.github.io/tag/devmapper.html">devmapper</a>,    <a href="https://sthbrx.github.io/tag/lvm.html">lvm</a>,    <a href="https://sthbrx.github.io/tag/cgroups.html">cgroups</a>,    <a href="https://sthbrx.github.io/tag/numa.html">numa</a>,    <a href="https://sthbrx.github.io/tag/development.html">Development</a>,    <a href="https://sthbrx.github.io/tag/netboot.html">netboot</a>,    <a href="https://sthbrx.github.io/tag/pxe.html">pxe</a>,    <a href="https://sthbrx.github.io/tag/education.html">Education</a>,    <a href="https://sthbrx.github.io/tag/work-experience.html">work experience</a>,    <a href="https://sthbrx.github.io/tag/asm.html">asm</a>,    <a href="https://sthbrx.github.io/tag/vdso.html">vdso</a>,    <a href="https://sthbrx.github.io/tag/snowpatch.html">snowpatch</a>,    <a href="https://sthbrx.github.io/tag/tools.html">tools</a>,    <a href="https://sthbrx.github.io/tag/intern.html">intern</a>,    <a href="https://sthbrx.github.io/tag/srop.html">SROP</a>,    <a href="https://sthbrx.github.io/tag/mitigation.html">mitigation</a>,    <a href="https://sthbrx.github.io/tag/double.html">double</a>,    <a href="https://sthbrx.github.io/tag/float.html">float</a>,    <a href="https://sthbrx.github.io/tag/hex.html">hex</a>,    <a href="https://sthbrx.github.io/tag/debugging.html">debugging</a>,    <a href="https://sthbrx.github.io/tag/skiboot.html">skiboot</a>,    <a href="https://sthbrx.github.io/tag/opal.html">OPAL</a>,    <a href="https://sthbrx.github.io/tag/fsp.html">FSP</a>,    <a href="https://sthbrx.github.io/tag/patches.html">patches</a>,    <a href="https://sthbrx.github.io/tag/ipmi.html">ipmi</a>,    <a href="https://sthbrx.github.io/tag/based16.html">based16</a>,    <a href="https://sthbrx.github.io/tag/linux-gods.html">Linux Gods</a>,    <a href="https://sthbrx.github.io/tag/ozlabs.html">Ozlabs</a>,    <a href="https://sthbrx.github.io/tag/offtopic.html">offtopic</a>,    <a href="https://sthbrx.github.io/tag/autoboot.html">autoboot</a>,    <a href="https://sthbrx.github.io/tag/kexec.html">kexec</a>,    <a href="https://sthbrx.github.io/tag/aufs.html">aufs</a>,    <a href="https://sthbrx.github.io/tag/overlay.html">overlay</a>,    <a href="https://sthbrx.github.io/tag/php.html">php</a>,    <a href="https://sthbrx.github.io/tag/capi.html">capi</a>  </section>


    <section>
        <h1>Social</h1>
        <ul>
            <li><a href="https://sthbrx.github.io/rss.xml" type="application/rss+xml" rel="alternate">RSS</a></li>
            <li><a href="https://github.com/sthbrx/" target="_blank">GitHub</a></li>
            <li><a href="https://lists.ozlabs.org/listinfo/linuxppc-dev" target="_blank">linuxppc mailing list</a></li>
            <li><a href="https://lists.ozlabs.org/listinfo/skiboot" target="_blank">Skiboot mailing list</a></li>
        </ul>
    </section>
    <section>
        <h1>Blogroll</h1>
        <ul>
            <li><a href="http://ozlabs.org" target="_blank">OzLabs</a></li>
        </ul>
    </section>

    <section>
        <h1>Disclaimer</h1>
        <div>
This blog represents the views of the individual authors, and doesn't necessarily represent IBM's positions, strategies or opinions.        </div>
    </section>
</aside>    </div>
  </div>
  <footer role="contentinfo"><p>
    Copyright &copy;  2015&ndash;2018  OzLabs &mdash;
  <span class="credit">Powered by <a href="http://getpelican.com">Pelican</a></span>
</p></footer>
</body>
</html>